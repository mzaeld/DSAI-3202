### **a. Execution time changes**  
- **Sequential:** Slowest since it runs on a single thread.  
- **Threading:** Slight improvement but limited by Python’s GIL.  
- **Multiprocessing:** Fastest due to true parallelism across CPU cores.  

### **c. Threading vs. Multiprocessing Performance**  
- **Threading** suffers from the GIL and doesn’t speed up CPU-bound tasks.  
- **Multiprocessing** bypasses the GIL, achieving better performance but with higher overhead.  

### **d. Challenges and Solutions**  
1. **GIL limitation** → Used multiprocessing for CPU-bound tasks.  
2. **Uneven workload** → Used chunking to split `n`.  
3. **Data synchronization** → Used `multiprocessing.Value` with `Lock()`.  
4. **Process overhead** → Limited processes to match CPU cores.  

### **e. When to Use Threading vs. Multiprocessing**  
- **Threading:** Best for I/O-bound tasks (e.g., file operations, web scraping).  
- **Multiprocessing:** Best for CPU-bound tasks (e.g., computations, data processing).  
